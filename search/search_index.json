{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Radio Bern Now Playing","text":"<p>This repo contains the tool we use to grab, aggregate and publish show, artist and track metadata from various sources.</p> <p>The nowplaying project grabs info from RaBes playout solution and publishes them to broadcast vectors like DAB+ and Webstreams.</p> <p>It also takes care of generating our live ticker at songticker.rabe.ch.</p>"},{"location":"#overview","title":"Overview","text":"<p>The nowplaying daemon takes various sources into account:</p> <ul> <li>The RaBe playout solution (via the virtual-saemubox project)</li> <li>Input from Klangbecken</li> </ul> <p>It then make an informed decision as to what should be our leading PAD data and pushes this to it's track handlers for the following sinks:</p> <ul> <li>DAB+ (via the ODR-EncoderManager API)</li> <li>Webstream by pushing to our Icecast instances</li> <li>Statically hosted XML output for browsers on songticker.rabe.ch</li> </ul> <p>The sources are currently individually implemented and are being replaced with generic RaBe CloudEvents based sources. In many places the legacy system is underdocumented and this documentation documents the new system.</p>"},{"location":"#usage","title":"Usage","text":"<p>TBD</p>"},{"location":"#rabe-cloudevents","title":"RaBe CloudEvents","text":"<p>The nowplaying projects receives httpd RaBe CloudEvents on a dedicated web service. It reacts to them depending on the event type and source</p> <p>It supports the following event types:</p> <ul> <li><code>ch.rabe.api.events.track.v1.trackStarted</code></li> <li><code>ch.rabe.api.events.track.v1.trackFinished</code></li> </ul> <p>An example <code>trackStarted</code> event looks like this:</p> <pre><code>{\n  \"specversion\": \"1.0\",\n  \"type\": \"ch.rabe.api.events.track.v1.trackStarted\",\n  \"source\": \"&lt;source&gt;\",\n  \"subject\": null,\n  \"id\": \"&lt;id&gt;\",\n  \"time\": \"2021-12-28T19:31:00Z\",\n  \"datacontenttype\": \"application/json\",\n  \"data\": {\n    \"item.artist\": \"hairmare fusion sounds collective\",\n    \"item.title\": \"C L O U D E V E N T W A V E\",\n    \"item.length\": 36000\n  }\n}\n</code></pre> <p>It can be sent to the nowplaying service using cURL as follows:</p> <pre><code>curl -vvv -u rabe:rabe -H 'Content-Type: application/cloudevents+json' -X POST -d '@event.json'  localhost:8080/webhook\n</code></pre> <p>In most cases the use of a cloudevents-sdk is recommended. The following example is based on the same python-sdk nowplaying uses.</p> <pre><code>import requests\n\nfrom cloudevents.http import CloudEvent, to_structured\n\ndef send_event(url, username, password):\n    # This data defines a cloudevent\n    attributes = {\n        \"specversion\": \"1.0\",\n        # as defined by the events-spec repo\n        \"type\": \"ch.rabe.api.events.track.v1.trackStarted\",\n        # for klangbecken the github link is always used as source (as per events-spec)\n        \"source\": \"https://github.com/radiorabe/klangbecken\",\n        # this should be generated and could/should point to a real\n        # URL on either https://klangbecken.service.int.example.org\n        # using a `crid://` URL based on the upcoming crid-spec.\n        \"id\": \"uri:demo:12345\",\n    }\n    data = {\n        \"item.title\": \"Track Title\",\n        \"item.artist\": \"Artist\",\n        # length in seconds, optional if you also implement sending the\n        # not \"completely specced yet\" trackFinished event\n        \"item.length\": 60,\n    }\n\n    event = CloudEvent(attributes, data)\n    headers, body = to_structured(event)\n\n    # send and print event\n    requests.post(url, headers=headers, data=body, auth=(username, password))\n    print(f\"Sent {event['id']} from {event['source']} with {event.data}\")\n\nif __name__ == \"__main__\":\n    # local config\n    url = \"https://nowplaying.service.int.example.org/webhook\"\n    username = \"rabe\"\n    password = \"rabe\"\n\n    # do work\n    send_event(url, username, password)\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":""},{"location":"#pre-commit-hook","title":"pre-commit hook","text":"<pre><code>pip install pre-commit\npip install -r requirements-dev.txt -U\npre-commit install\n</code></pre>"},{"location":"#testing","title":"testing","text":"<pre><code>pytest\n</code></pre>"},{"location":"#release-management","title":"Release Management","text":"<p>The CI/CD setup uses semantic commit messages following the conventional commits standard. There is a GitHub Action in .github/workflows/semantic-release.yaml that uses go-semantic-commit to create new releases.</p> <p>The commit message should be structured as follows:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre> <p>The commit contains the following structural elements, to communicate intent to the consumers of your library:</p> <ol> <li>fix: a commit of the type <code>fix</code> patches gets released with a PATCH version bump</li> <li>feat: a commit of the type <code>feat</code> gets released as a MINOR version bump</li> <li>BREAKING CHANGE: a commit that has a footer <code>BREAKING CHANGE:</code> gets released as a MAJOR version bump</li> <li>types other than <code>fix:</code> and <code>feat:</code> are allowed and don't trigger a release</li> </ol> <p>If a commit does not contain a conventional commit style message you can fix it during the squash and merge operation on the PR.</p> <p>Once a commit has landed on the <code>main</code> branch a release will be created and automatically published to pypi using the GitHub Action in .github/workflows/pypi.yaml which uses twine to publish the package to pypi. Additionaly a container image based on the RaBe Python Minimal Base Image is built and published using Docker build-push Action. This is managed in .github/workflows/release.yaml.</p>"},{"location":"#license","title":"License","text":"<p>This application is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, version 3 of the License.</p>"},{"location":"#copyright","title":"Copyright","text":"<p>Copyright (c) 2022 Radio Bern RaBe</p>"},{"location":"reference/api/","title":"Api","text":""},{"location":"reference/api/#api.ApiServer","title":"<code>ApiServer</code>","text":"<p>The API server.</p> Source code in <code>nowplaying/api.py</code> <pre><code>class ApiServer:\n    \"\"\"The API server.\"\"\"\n\n    def __init__(self, options, event_queue: Queue, realm: str = \"nowplaying\"):\n        self.options = options\n        self.event_queue = event_queue\n        self.realm = realm\n\n        self.url_map = Map([Rule(\"/webhook\", endpoint=\"webhook\")])\n\n    def run_server(self):\n        \"\"\"Run the API server.\"\"\"\n        if self.options.debug:\n            from werkzeug.serving import run_simple\n\n            self._server = run_simple(\n                self.options.apiBindAddress,\n                self.options.apiPort,\n                self,\n                use_debugger=True,\n                use_reloader=True,\n            )\n        else:  # pragma: no cover\n            cherrypy.tree.graft(self, \"/\")\n            cherrypy.server.unsubscribe()\n\n            self._server = cherrypy._cpserver.Server()\n\n            self._server.socket_host = self.options.apiBindAddress\n            self._server.socket_port = self.options.apiPort\n\n            self._server.subscribe()\n\n            cherrypy.engine.start()\n            cherrypy.engine.block()\n\n    def stop_server(self):\n        \"\"\"Stop the server.\"\"\"\n        self._server.stop()\n        cherrypy.engine.exit()\n\n    def __call__(self, environ, start_response):\n        return self.wsgi_app(environ, start_response)\n\n    def wsgi_app(self, environ, start_response):\n        request = Request(environ)\n        auth = request.authorization\n        if auth and self.check_auth(auth.username, auth.password):\n            response = self.dispatch_request(request)\n        else:\n            response = self.auth_required(request)\n        return response(environ, start_response)\n\n    def check_auth(self, username, password):\n        return (\n            username in self.options.apiAuthUsers\n            and self.options.apiAuthUsers[username] == password\n        )\n\n    def auth_required(self, request):\n        return Response(\n            \"Could not verify your access level for that URL.\\n\"\n            \"You have to login with proper credentials\",\n            401,\n            {\"WWW-Authenticate\": f'Basic realm=\"{self.realm}\"'},\n        )\n\n    def dispatch_request(self, request):\n        adapter = self.url_map.bind_to_environ(request.environ)\n        try:\n            endpoint, values = adapter.match()\n            return getattr(self, f\"on_{endpoint}\")(request, **values)\n        except HTTPException as e:\n            return Response(\n                json.dumps(e.description),\n                e.code,\n                {\"Content-Type\": \"application/json\"},\n            )\n\n    def on_webhook(self, request):\n        \"\"\"Receive a CloudEvent and put it into the event queue.\"\"\"\n        logger.warning(\"Received a webhook\")\n        if (\n            request.headers.get(\"Content-Type\")\n            not in _RABE_CLOUD_EVENTS_SUPPORTED_MEDIA_TYPES\n        ):\n            raise UnsupportedMediaType()\n        try:\n            event = from_http(request.headers, request.data)\n        except CloudEventException as error:\n            raise BadRequest(description=f\"{error}\")\n\n        try:\n            crid = cridlib.parse(event[\"id\"])\n            logger.debug(\"Detected CRID: %s\", crid)\n        except cridlib.CRIDError as error:\n            raise BadRequest(\n                description=f\"CRID '{event['id']}' is not a RaBe CRID\"\n            ) from error\n\n        logger.info(\"Received event: %s\", event)\n\n        if event[\"type\"] in _RABE_CLOUD_EVENTS_SUBS:\n            self.event_queue.put(event)\n\n        return Response(status=\"200 Event Received\")\n</code></pre>"},{"location":"reference/api/#api.ApiServer.on_webhook","title":"<code>on_webhook(request)</code>","text":"<p>Receive a CloudEvent and put it into the event queue.</p> Source code in <code>nowplaying/api.py</code> <pre><code>def on_webhook(self, request):\n    \"\"\"Receive a CloudEvent and put it into the event queue.\"\"\"\n    logger.warning(\"Received a webhook\")\n    if (\n        request.headers.get(\"Content-Type\")\n        not in _RABE_CLOUD_EVENTS_SUPPORTED_MEDIA_TYPES\n    ):\n        raise UnsupportedMediaType()\n    try:\n        event = from_http(request.headers, request.data)\n    except CloudEventException as error:\n        raise BadRequest(description=f\"{error}\")\n\n    try:\n        crid = cridlib.parse(event[\"id\"])\n        logger.debug(\"Detected CRID: %s\", crid)\n    except cridlib.CRIDError as error:\n        raise BadRequest(\n            description=f\"CRID '{event['id']}' is not a RaBe CRID\"\n        ) from error\n\n    logger.info(\"Received event: %s\", event)\n\n    if event[\"type\"] in _RABE_CLOUD_EVENTS_SUBS:\n        self.event_queue.put(event)\n\n    return Response(status=\"200 Event Received\")\n</code></pre>"},{"location":"reference/api/#api.ApiServer.run_server","title":"<code>run_server()</code>","text":"<p>Run the API server.</p> Source code in <code>nowplaying/api.py</code> <pre><code>def run_server(self):\n    \"\"\"Run the API server.\"\"\"\n    if self.options.debug:\n        from werkzeug.serving import run_simple\n\n        self._server = run_simple(\n            self.options.apiBindAddress,\n            self.options.apiPort,\n            self,\n            use_debugger=True,\n            use_reloader=True,\n        )\n    else:  # pragma: no cover\n        cherrypy.tree.graft(self, \"/\")\n        cherrypy.server.unsubscribe()\n\n        self._server = cherrypy._cpserver.Server()\n\n        self._server.socket_host = self.options.apiBindAddress\n        self._server.socket_port = self.options.apiPort\n\n        self._server.subscribe()\n\n        cherrypy.engine.start()\n        cherrypy.engine.block()\n</code></pre>"},{"location":"reference/api/#api.ApiServer.stop_server","title":"<code>stop_server()</code>","text":"<p>Stop the server.</p> Source code in <code>nowplaying/api.py</code> <pre><code>def stop_server(self):\n    \"\"\"Stop the server.\"\"\"\n    self._server.stop()\n    cherrypy.engine.exit()\n</code></pre>"},{"location":"reference/daemon/","title":"Daemon","text":""},{"location":"reference/daemon/#daemon.NowPlayingDaemon","title":"<code>NowPlayingDaemon</code>","text":"<p>The daemon of nowplaying runs at all time and coordinates the i/o.</p> Source code in <code>nowplaying/daemon.py</code> <pre><code>class NowPlayingDaemon:\n    \"\"\"The daemon of nowplaying runs at all time and coordinates the i/o.\"\"\"\n\n    \"\"\"initialize last_input to a know value.\"\"\"\n    last_input = 1\n\n    def __init__(self, options):\n        self.options = options\n\n        self.event_queue = Queue()\n        self.saemubox = SaemuBox(\n            self.options.saemubox_ip, self.options.check_saemubox_sender\n        )\n\n    def main(self):  # pragma: no cover\n        # TODO test once there is not saemubox in the loop\n        logger.info(\"Starting up now-playing daemon\")\n        self.saemubox.run()\n\n        try:\n            self.register_signal_handlers()\n\n            input_handler = self.get_input_handler()\n        except Exception as e:\n            logger.exception(\"Error: %s\", e)\n            sys.exit(-1)\n\n        _thread = Thread(target=self._main_loop, args=(input_handler,))\n        _thread.daemon = True\n        _thread.start()\n\n        self._start_apiserver()  # blocking\n\n    def _start_apiserver(self):\n        \"\"\"Start the API server.\"\"\"\n        self._api = ApiServer(self.options, self.event_queue)\n        self._api.run_server()  # blocking\n\n    def _stop_apiserver(self):\n        \"\"\"Stop the API server.\"\"\"\n        logger.info(\"Stopping API server\")\n        self._api.stop_server()\n\n    def _main_loop(self, input_handler: InputHandler):  # pragma: no cover\n        \"\"\"\n        Run main loop of the daemon.\n\n        Should be run in a thread.\n        \"\"\"\n        logger.info(\"Starting main loop\")\n        while True:\n            try:\n                saemubox_id = self.poll_saemubox()\n\n                while not self.event_queue.empty():\n                    logger.debug(\"Queue size: %i\" % self.event_queue.qsize())\n                    event: CloudEvent = self.event_queue.get()\n                    logger.info(\n                        \"Handling update from event: %s, source: %s\"\n                        % (event[\"type\"], event[\"source\"])\n                    )\n                    input_handler.update(saemubox_id, event)\n\n                input_handler.update(saemubox_id)\n            except Exception as e:\n                logger.exception(\"Error: %s\", e)\n\n            time.sleep(self.options.sleepSeconds)\n\n    def register_signal_handlers(self):\n        logger.debug(\"Registering signal handler\")\n        signal.signal(signal.SIGINT, self.signal_handler)\n        # signal.signal(signal.SIGKIL, self.signal_handler)\n\n    def signal_handler(self, signum, frame):\n        logger.debug(\"Signal %i caught\" % signum)\n\n        if signum == signal.SIGINT or signum == signal.SIGKILL:\n            logger.info(\"Signal %i caught, terminating.\" % signum)\n            self._stop_apiserver()\n            sys.exit(os.EX_OK)\n\n    def get_track_handler(self):  # pragma: no cover\n        # TODO test once options have been refactored with v3\n        handler = TrackEventHandler()\n        [\n            handler.register_observer(\n                IcecastTrackObserver(\n                    # TODO v3 remove uername and password\n                    #          because we mandate specifying via url\n                    options=IcecastTrackObserver.Options(\n                        url=url,\n                        username=\"source\",\n                        password=self.options.icecastPassword,\n                    )\n                )\n            )\n            for url in self.options.icecast\n        ]\n        [\n            handler.register_observer(\n                DabAudioCompanionTrackObserver(\n                    options=DabAudioCompanionTrackObserver.Options(\n                        url=url, dl_plus=self.options.dab_send_dls\n                    )\n                )\n            )\n            for url in self.options.dab\n        ]\n        handler.register_observer(\n            TickerTrackObserver(\n                options=TickerTrackObserver.Options(\n                    file_path=self.options.tickerOutputFile\n                )\n            )\n        )\n        if self.options.dab_smc:\n            handler.register_observer(\n                SmcFtpTrackObserver(\n                    options=SmcFtpTrackObserver.Options(\n                        hostname=self.options.dab_smc_ftp_hostname,\n                        username=self.options.dab_smc_ftp_username,\n                        password=self.options.dab_smc_ftp_password,\n                    )\n                )\n            )\n\n        return handler\n\n    def get_input_handler(self):  # pragma: no cover\n        # TODO test once options have been refactored with v3\n        handler = InputHandler()\n        track_handler = self.get_track_handler()\n\n        klangbecken = inputObservers.KlangbeckenInputObserver(\n            self.options.currentShowUrl, self.options.inputFile\n        )\n        klangbecken.add_track_handler(track_handler)\n        handler.register_observer(klangbecken)\n\n        nonklangbecken = inputObservers.NonKlangbeckenInputObserver(\n            self.options.currentShowUrl\n        )\n        nonklangbecken.add_track_handler(track_handler)\n        handler.register_observer(nonklangbecken)\n\n        return handler\n\n    def poll_saemubox(self) -&gt; int:  # pragma: no cover\n        \"\"\"\n        Poll Saemubox for new data.\n\n        Should be run once per main loop.\n\n        TODO v3 remove once replaced with pathfinder\n        \"\"\"\n\n        saemubox_id = self.saemubox.get_active_output_id()\n        logger.debug(\"S\u00e4mubox id: %i\" % saemubox_id)\n\n        if self.last_input != saemubox_id:\n            logger.info(\n                'S\u00e4mubox changed from \"%s\" to \"%s\"'\n                % (\n                    self.saemubox.get_id_as_name(self.last_input),\n                    self.saemubox.get_id_as_name(saemubox_id),\n                )\n            )\n\n        self.last_input = saemubox_id\n        return saemubox_id\n</code></pre>"},{"location":"reference/daemon/#daemon.NowPlayingDaemon.poll_saemubox","title":"<code>poll_saemubox()</code>","text":"<p>Poll Saemubox for new data.</p> <p>Should be run once per main loop.</p> <p>TODO v3 remove once replaced with pathfinder</p> Source code in <code>nowplaying/daemon.py</code> <pre><code>def poll_saemubox(self) -&gt; int:  # pragma: no cover\n    \"\"\"\n    Poll Saemubox for new data.\n\n    Should be run once per main loop.\n\n    TODO v3 remove once replaced with pathfinder\n    \"\"\"\n\n    saemubox_id = self.saemubox.get_active_output_id()\n    logger.debug(\"S\u00e4mubox id: %i\" % saemubox_id)\n\n    if self.last_input != saemubox_id:\n        logger.info(\n            'S\u00e4mubox changed from \"%s\" to \"%s\"'\n            % (\n                self.saemubox.get_id_as_name(self.last_input),\n                self.saemubox.get_id_as_name(saemubox_id),\n            )\n        )\n\n    self.last_input = saemubox_id\n    return saemubox_id\n</code></pre>"},{"location":"reference/main/","title":"Main","text":""},{"location":"reference/main/#main.NowPlaying","title":"<code>NowPlaying</code>","text":"Source code in <code>nowplaying/main.py</code> <pre><code>class NowPlaying:\n    def run(self):\n        \"\"\"Load configuration, initialize environment and start nowplaying daemon.\"\"\"\n        self.options = Options()\n        self.options.parse_known_args()\n\n        self._setup_otel()\n        socket.setdefaulttimeout(self.options.socketDefaultTimeout)\n        self._run_daemon()\n\n    def _setup_otel(self):  # pragma: no cover\n        if not self.options.debug:\n            setup_otel(self.options.otlp_enable)\n\n    def _run_daemon(self):\n        \"\"\"Start nowplaying daemon.\"\"\"\n        NowPlayingDaemon(self.options).main()\n</code></pre>"},{"location":"reference/main/#main.NowPlaying.run","title":"<code>run()</code>","text":"<p>Load configuration, initialize environment and start nowplaying daemon.</p> Source code in <code>nowplaying/main.py</code> <pre><code>def run(self):\n    \"\"\"Load configuration, initialize environment and start nowplaying daemon.\"\"\"\n    self.options = Options()\n    self.options.parse_known_args()\n\n    self._setup_otel()\n    socket.setdefaulttimeout(self.options.socketDefaultTimeout)\n    self._run_daemon()\n</code></pre>"},{"location":"reference/options/","title":"Options","text":""},{"location":"reference/options/#options.Options","title":"<code>Options</code>","text":"<p>Contain all hardcoded and loaded from configargparse options.</p> Source code in <code>nowplaying/options.py</code> <pre><code>class Options:\n    \"\"\"Contain all hardcoded and loaded from configargparse options.\"\"\"\n\n    \"\"\"How many seconds the main daemon loop sleeps.\"\"\"\n    sleepSeconds = 1\n\n    \"\"\"Default socket of 2 minutes, to prevent endless hangs on HTTP requests.\"\"\"\n    socketDefaultTimeout = 120\n\n    def __init__(self):\n        \"\"\"Configure configargparse.\"\"\"\n        self.__args = configargparse.ArgParser(\n            default_config_files=[\"/etc/nowplaying/conf.d/*.conf\", \"~/.nowplayingrc\"]\n        )\n        # TODO v3 remove this option\n        self.__args.add_argument(\n            \"-b\",\n            \"--saemubox-ip\",\n            dest=\"saemubox_ip\",\n            help=\"IP address of SAEMUBOX\",\n            default=\"\",\n        )\n        # TODO v3 remove this option\n        self.__args.add_argument(\n            \"--check-saemubox-sender\",\n            dest=\"check_saemubox_sender\",\n            help=\"Check SRC SAEMUBOX IP\",\n            default=True,\n        )\n        IcecastTrackObserver.Options.args(self.__args)\n        DabAudioCompanionTrackObserver.Options.args(self.__args)\n        SmcFtpTrackObserver.Options.args(self.__args)\n        TickerTrackObserver.Options.args(self.__args)\n        self.__args.add_argument(\n            \"-s\",\n            \"--show\",\n            dest=\"currentShowUrl\",\n            help=\"Current Show URL e.g. 'https://libretime.int.example.org/api/live-info-v2/format/json'\",\n        )\n        # TODO v3 remove this option\n        self.__args.add_argument(\n            \"--input-file\",\n            dest=\"inputFile\",\n            help=(\n                \"XML 'now-playing' input file location, \"\n                \"disable input by passing empty string, ie. --input-file=''\"\n            ),\n            default=\"/home/endlosplayer/Eingang/now-playing.xml\",\n        )\n        self.__args.add_argument(\n            \"--api-bind-address\",\n            dest=\"apiBindAddress\",\n            help=\"Bind address for the API server\",\n            default=\"0.0.0.0\",\n        )\n        self.__args.add_argument(\n            \"--api-port\",\n            type=int,\n            dest=\"apiPort\",\n            help=\"Bind port for the API server\",\n            default=8080,\n        )\n        self.__args.add_argument(\n            \"--api-auth-users\",\n            dest=\"apiAuthUsers\",\n            help=\"API Auth Users\",\n            default={\"rabe\": \"rabe\"},\n        )\n        self.__args.add_argument(\n            \"--instrumentation-otlp-enable\",\n            type=bool,\n            nargs=\"?\",\n            const=True,\n            dest=\"otlp_enable\",\n            help=\"Enable OpenTelemetry Protocol (OTLP) exporter (default: False)\",\n            default=False,\n            env_var=\"NOWPLAYING_INSTRUMENTATION_OTLP_ENABLE\",\n        )\n        self.__args.add_argument(\n            \"--debug\",\n            type=bool,\n            nargs=\"?\",\n            const=True,\n            dest=\"debug\",\n            help=\"Show debug messages\",\n            default=False,\n        )\n\n    def parse_known_args(self):\n        \"\"\"Parse known args with configargparse.\"\"\"\n        self.__args.parse_known_args(namespace=self)\n</code></pre>"},{"location":"reference/options/#options.Options.sleepSeconds","title":"<code>sleepSeconds = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Default socket of 2 minutes, to prevent endless hangs on HTTP requests.</p>"},{"location":"reference/options/#options.Options.__init__","title":"<code>__init__()</code>","text":"<p>Configure configargparse.</p> Source code in <code>nowplaying/options.py</code> <pre><code>def __init__(self):\n    \"\"\"Configure configargparse.\"\"\"\n    self.__args = configargparse.ArgParser(\n        default_config_files=[\"/etc/nowplaying/conf.d/*.conf\", \"~/.nowplayingrc\"]\n    )\n    # TODO v3 remove this option\n    self.__args.add_argument(\n        \"-b\",\n        \"--saemubox-ip\",\n        dest=\"saemubox_ip\",\n        help=\"IP address of SAEMUBOX\",\n        default=\"\",\n    )\n    # TODO v3 remove this option\n    self.__args.add_argument(\n        \"--check-saemubox-sender\",\n        dest=\"check_saemubox_sender\",\n        help=\"Check SRC SAEMUBOX IP\",\n        default=True,\n    )\n    IcecastTrackObserver.Options.args(self.__args)\n    DabAudioCompanionTrackObserver.Options.args(self.__args)\n    SmcFtpTrackObserver.Options.args(self.__args)\n    TickerTrackObserver.Options.args(self.__args)\n    self.__args.add_argument(\n        \"-s\",\n        \"--show\",\n        dest=\"currentShowUrl\",\n        help=\"Current Show URL e.g. 'https://libretime.int.example.org/api/live-info-v2/format/json'\",\n    )\n    # TODO v3 remove this option\n    self.__args.add_argument(\n        \"--input-file\",\n        dest=\"inputFile\",\n        help=(\n            \"XML 'now-playing' input file location, \"\n            \"disable input by passing empty string, ie. --input-file=''\"\n        ),\n        default=\"/home/endlosplayer/Eingang/now-playing.xml\",\n    )\n    self.__args.add_argument(\n        \"--api-bind-address\",\n        dest=\"apiBindAddress\",\n        help=\"Bind address for the API server\",\n        default=\"0.0.0.0\",\n    )\n    self.__args.add_argument(\n        \"--api-port\",\n        type=int,\n        dest=\"apiPort\",\n        help=\"Bind port for the API server\",\n        default=8080,\n    )\n    self.__args.add_argument(\n        \"--api-auth-users\",\n        dest=\"apiAuthUsers\",\n        help=\"API Auth Users\",\n        default={\"rabe\": \"rabe\"},\n    )\n    self.__args.add_argument(\n        \"--instrumentation-otlp-enable\",\n        type=bool,\n        nargs=\"?\",\n        const=True,\n        dest=\"otlp_enable\",\n        help=\"Enable OpenTelemetry Protocol (OTLP) exporter (default: False)\",\n        default=False,\n        env_var=\"NOWPLAYING_INSTRUMENTATION_OTLP_ENABLE\",\n    )\n    self.__args.add_argument(\n        \"--debug\",\n        type=bool,\n        nargs=\"?\",\n        const=True,\n        dest=\"debug\",\n        help=\"Show debug messages\",\n        default=False,\n    )\n</code></pre>"},{"location":"reference/options/#options.Options.parse_known_args","title":"<code>parse_known_args()</code>","text":"<p>Parse known args with configargparse.</p> Source code in <code>nowplaying/options.py</code> <pre><code>def parse_known_args(self):\n    \"\"\"Parse known args with configargparse.\"\"\"\n    self.__args.parse_known_args(namespace=self)\n</code></pre>"},{"location":"reference/otel/","title":"Otel","text":"<p>OpenTelemetry for nowplaying.</p> <p>This sets up our logging stack to use OpenTelemetry.</p>"},{"location":"reference/otel/#otel.SourceAttributeFilter","title":"<code>SourceAttributeFilter</code>","text":"<p>             Bases: <code>Filter</code></p> <p>Used on the handler to ensure that some attributes are carried over to otel.</p> Source code in <code>nowplaying/otel.py</code> <pre><code>class SourceAttributeFilter(logging.Filter):  # pragma: no cover\n    \"\"\"Used on the handler to ensure that some attributes are carried over to otel.\"\"\"\n\n    def filter(self, record) -&gt; bool:\n        record.source_name = record.name\n        record.source_pathname = os.path.relpath(\n            record.pathname, os.path.dirname(os.path.dirname(__file__))\n        )\n        record.source_lineno = record.lineno\n        return True\n</code></pre>"},{"location":"reference/otel/#otel.setup_otel","title":"<code>setup_otel(otlp_enable=False)</code>","text":"<p>Configure opentelemetry logging to stdout and collector.</p> Source code in <code>nowplaying/otel.py</code> <pre><code>def setup_otel(otlp_enable=False):  # pragma: no cover\n    \"\"\"Configure opentelemetry logging to stdout and collector.\"\"\"\n    root = logging.getLogger()\n    root.setLevel(logging.INFO)\n\n    logger_provider = LoggerProvider(\n        resource=Resource.create(\n            {\n                \"service.name\": \"nowplaying\",\n            },\n        )\n    )\n    set_logger_provider(logger_provider)\n\n    console_exporter = ConsoleLogExporter(\n        formatter=lambda record: _log_formatter(record)\n    )\n    logger_provider.add_log_record_processor(SimpleLogRecordProcessor(console_exporter))\n\n    if otlp_enable:\n        oltp_exporter = OTLPLogExporter(insecure=True)\n        logger_provider.add_log_record_processor(BatchLogRecordProcessor(oltp_exporter))\n\n    handler = LoggingHandler(level=logging.NOTSET, logger_provider=logger_provider)\n    handler.addFilter(SourceAttributeFilter())\n\n    root.addHandler(handler)\n\n    logger = logging.getLogger(__name__)\n    logger.info(\"Opentelemetry Configured (OTLP: %s)\", otlp_enable)\n</code></pre>"},{"location":"reference/util/","title":"Util","text":""},{"location":"reference/util/#util.parse_icecast_url","title":"<code>parse_icecast_url(url)</code>","text":"<p>Parse an Icecast URL into parts relevant to :class:<code>IcecastTrackObserver</code>.</p> <p>Use it to grab the username, password, and mountpoint from the URL.</p> <p>parse_icecast_url(\"http://user:password@localhost:80/?mount=foo.mp3\") ('http://localhost:80/', 'user', 'password', 'foo.mp3')</p> <p>It returns None values for missing parts.</p> <p>parse_icecast_url(\"http://localhost/\") ('http://localhost:80/', None, None, None)</p> <p>It supports https URLs.</p> <p>parse_icecast_url(\"https://localhost/\") ('https://localhost:443/', None, None, None)</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The Icecast URL to parse.</p> required <p>Returns:     Tuple[str, Optional[str], Optional[str], Optional[str]]:         The URL, username, password, and mountpoint.</p> Source code in <code>nowplaying/util.py</code> <pre><code>def parse_icecast_url(\n    url: str,\n) -&gt; tuple[str, str | None, str | None, str | None]:\n    \"\"\"Parse an Icecast URL into parts relevant to :class:`IcecastTrackObserver`.\n\n    Use it to grab the username, password, and mountpoint from the URL.\n\n    &gt;&gt;&gt; parse_icecast_url(\"http://user:password@localhost:80/?mount=foo.mp3\")\n    ('http://localhost:80/', 'user', 'password', 'foo.mp3')\n\n    It returns None values for missing parts.\n\n    &gt;&gt;&gt; parse_icecast_url(\"http://localhost/\")\n    ('http://localhost:80/', None, None, None)\n\n    It supports https URLs.\n\n    &gt;&gt;&gt; parse_icecast_url(\"https://localhost/\")\n    ('https://localhost:443/', None, None, None)\n\n    Args:\n        url (str): The Icecast URL to parse.\n    Returns:\n        Tuple[str, Optional[str], Optional[str], Optional[str]]:\n            The URL, username, password, and mountpoint.\n    \"\"\"\n    parsed = urlparse(url)\n    port = parsed.port or parsed.scheme == \"https\" and 443 or 80\n    url = parsed._replace(query=\"\", netloc=f\"{parsed.hostname}:{port}\").geturl()\n    username = parsed.username\n    password = parsed.password\n    mount = None\n    try:\n        mount = parse_qs(parsed.query)[\"mount\"][0]\n    except KeyError:\n        logger.warning(\"Missing mount parameter in URL %s\" % url)\n    return (url, username, password, mount)\n</code></pre>"},{"location":"reference/input/handler/","title":"Input","text":""},{"location":"reference/input/handler/#input.handler.InputHandler","title":"<code>InputHandler</code>","text":"<p>Inform all registered input-event observers about an input status.</p> <p>This is the subject of the classical observer pattern.</p> Source code in <code>nowplaying/input/handler.py</code> <pre><code>class InputHandler:\n    \"\"\"Inform all registered input-event observers about an input status.\n\n    This is the subject of the classical observer pattern.\n    \"\"\"\n\n    def __init__(self):\n        self._observers: list[InputObserver] = []\n\n    def register_observer(self, observer: InputObserver):\n        logger.info(\"Registering InputObserver '%s'\" % observer.__class__.__name__)\n        self._observers.append(observer)\n\n    def remove_observer(self, observer: InputObserver):\n        self._observers.remove(observer)\n\n    def update(self, saemubox_id: int, event: CloudEvent = None):\n        for observer in self._observers:\n            logger.debug(\"Sending update event to observer %s\" % observer.__class__)\n\n            try:\n                observer.update(saemubox_id, event)\n            except Exception as e:  # pragma: no cover\n                # TODO test once replaced with non generic exception\n                logger.error(f\"InputObserver ({observer.__class__}): {e}\")\n                logger.exception(e)\n</code></pre>"},{"location":"reference/input/observer/","title":"Observer","text":""},{"location":"reference/input/observer/#input.observer.InputObserver","title":"<code>InputObserver</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract base for all InputObservers.</p> Source code in <code>nowplaying/input/observer.py</code> <pre><code>class InputObserver(ABC):\n    \"\"\"Abstract base for all InputObservers.\"\"\"\n\n    _SHOW_NAME_KLANGBECKEN = \"Klangbecken\"\n    _SHOW_URL_KLANGBECKEN = \"http://www.rabe.ch/sendungen/musik/klangbecken.html\"\n\n    def __init__(self, current_show_url: str):\n        self.show: Show\n        self.track_handler: TrackEventHandler\n        self.previous_saemubox_id: int = -1\n        self.first_run = True\n        self.previous_show_uuid = \"\"\n\n        self.current_show_url = current_show_url\n\n        self.showclient = client.ShowClient(current_show_url)\n        self.show = self.showclient.get_show_info()\n\n    def add_track_handler(self, track_handler: TrackEventHandler):\n        self.track_handler = track_handler\n\n    def update(self, saemubox_id: int, event: CloudEvent = None):\n        # TODO v3-prep refactor to use :meth:`handles` instead of :meth:`handle_id`\n        if self.handle_id(saemubox_id, event):\n            self.handle(event)\n\n    @abstractmethod\n    # TODO v3 remove this method\n    def handle_id(\n        self, saemubox_id: int, event: CloudEvent = None\n    ):  # pragma: no coverage\n        pass\n\n    @abstractmethod\n    # TODO v3 remove this method\n    def handle(self, event: CloudEvent = None):  # pragma: no coverage\n        pass\n\n    @abstractmethod\n    def handles(self, event: CloudEvent) -&gt; bool:  # pragma: no coverage\n        pass\n\n    @abstractmethod\n    def event(self, event: CloudEvent):  # pragma: no coverage\n        pass\n</code></pre>"},{"location":"reference/input/observer/#input.observer.KlangbeckenInputObserver","title":"<code>KlangbeckenInputObserver</code>","text":"<p>             Bases: <code>InputObserver</code></p> <p>Observe when S\u00e4mu Box says Klangbecken we have now-playing.xml input.</p> Source code in <code>nowplaying/input/observer.py</code> <pre><code>class KlangbeckenInputObserver(InputObserver):\n    \"\"\"Observe when S\u00e4mu Box says Klangbecken we have now-playing.xml input.\"\"\"\n\n    def __init__(\n        self, current_show_url: str, input_file: str = None\n    ):  # pragma: no coverage\n        # TODO test once input file is replaced with api\n        if input_file:\n            warnings.warn(\n                \"The now-playing.xml format from Loopy/Klangbecken \"\n                \"will be replaced in the future\",\n                PendingDeprecationWarning,\n            )\n            self.input_file = input_file\n            self.last_modify_time = os.stat(self.input_file).st_mtime\n\n        self.track: Track\n        super().__init__(current_show_url)\n\n    def handles(self, event: CloudEvent) -&gt; bool:\n        # TODO v3-prep call :meth:`handle_id` from here\n        #      needs saemubox_id compat workaround\n        # TODO v3 remove call to :meth:`handle_id`\n        # TODO make magic string configurable\n        # TODO check if source is currently on-air\n        if not event:  # pragma: no coverage\n            # TODO remove checking for None once only events exist\n            return False\n        return event[\"source\"] == \"https://github/radiorabe/klangbecken\"\n\n    def event(self, event: CloudEvent):\n        self._handle(event)\n\n    def handle_id(self, saemubox_id: int, event: CloudEvent = None):\n        # only handle Klangbecken output\n        if saemubox_id == 1:\n            return True\n\n        # TODO v3-prep make this get called from :meth:`handles`\n        return self.handles(event)\n\n    def handle(self, event: CloudEvent = None):\n        self._handle(event)\n\n    def _handle(self, event: CloudEvent = None):\n        \"\"\"Handle actual RaBe CloudEevent.\n\n        TODO v3: move into :meth:`event`\n                 once :meth:`handle` and :meth:`handle_id` have been yeeted\n        TODO v3: remove all refs to input_file and it's modify time\n                 once we use event handlers\n        \"\"\"\n        if not event:\n            # @TODO: replace the stat method with inotify\n            modify_time = os.stat(self.input_file).st_mtime\n\n        # @TODO: Need to check if we have a stale file and send default\n        #        track infos in this case. This might happend if loopy\n        #        went out for lunch...\n        #        pseudo code: now &gt; modify_time + self.track.get_duration()\n\n        if self.first_run or event or modify_time &gt; self.last_modify_time:\n            logger.info(\"Now playing file changed\")\n\n            self.show = self.showclient.get_show_info()\n            if not event:\n                self.last_modify_time = modify_time\n\n            if event:\n                self.track = self.parse_event(event)\n                self.first_run = False\n\n            logger.info(\"First run: %s\" % self.first_run)\n\n            if not self.first_run:  # pragma: no coverage\n                # TODO test once we don't have to care about\n                #      mtime/inotify because it's an api\n                logger.info(\"calling track_finished\")\n                self.track_handler.track_finished(self.track)\n\n            if not event:\n                # TODO remove once legacy xml is gone\n                self.track = self.get_track_info()\n\n            # Klangbecken acts as a failover and last resort input, if other\n            # active inputs are silent or have problems.\n            # Therefore the show's name should always be Klangbecken, regardless\n            # of what loopy thinks.\n            if self.show.name != self._SHOW_NAME_KLANGBECKEN:\n                logger.info(\n                    \"Klangbecken Input active, overriding current show '%s' with '%s'\"\n                    % (self.show.name, self._SHOW_NAME_KLANGBECKEN)\n                )\n\n                self.show = Show()\n                self.show.set_name(self._SHOW_NAME_KLANGBECKEN)\n                self.show.set_url(self._SHOW_URL_KLANGBECKEN)\n\n                # Set the show's end time to the one of the track, as we have\n                # no idea for how long the Klangbecken input will be active.\n                # The show's start time is initially set to now.\n                self.show.set_endtime(self.track.endtime)\n\n            self.track.set_show(self.show)\n\n            # TODO: or finished?\n            self.track_handler.track_started(self.track)\n\n            self.first_run = False\n\n    def get_track_info(self):\n        # TODO v3 remove method once legacy xml is gone\n        dom = xml.dom.minidom.parse(self.input_file)\n\n        # default track info\n        track_info = {\n            \"artist\": DEFAULT_ARTIST,\n            \"title\": DEFAULT_TITLE,\n            \"album\": \"\",\n            \"track\": \"\",\n            \"time\": \"\",\n        }\n\n        song = dom.getElementsByTagName(\"song\")\n\n        if len(song) == 0 or song[0].hasChildNodes() is False:  # pragma: no coverage\n            # TODO replace with non generic exception and test\n            raise Exception(\"No &lt;song&gt; tag found\")\n\n        song = song[0]\n\n        for name in list(track_info.keys()):\n            elements = song.getElementsByTagName(name)\n\n            if len(elements) == 0:  # pragma: no coverage\n                # TODO replace with non generic exception and test\n                raise Exception(\"No &lt;%s&gt; tag found\" % name)\n            elif elements[0].hasChildNodes():\n                element_data = elements[0].firstChild.data.strip()\n\n                if element_data != \"\":\n                    track_info[name] = element_data\n                else:  # pragma: no coverage\n                    logger.info(\"Element %s has empty value, ignoring\" % name)\n\n        if not song.hasAttribute(\"timestamp\"):  # pragma: no coverage\n            # TODO replace with non generic exception and test\n            raise Exception(\"Song timestamp attribute is missing\")\n\n        # set the start time and append the missing UTC offset\n        # @TODO: The UTC offset should be provided by the now playing XML\n        #        generated by Thomas\n        # ex.: 2012-05-15T09:47:07+02:00\n        track_info[\"start_timestamp\"] = song.getAttribute(\"timestamp\") + time.strftime(\n            \"%z\"\n        )\n\n        current_track = Track()\n\n        current_track.set_artist(track_info[\"artist\"])\n        current_track.set_title(track_info[\"title\"])\n        current_track.set_album(track_info[\"album\"])\n\n        # Store as UTC datetime object\n        current_track.set_starttime(\n            isodate.parse_datetime(track_info[\"start_timestamp\"]).astimezone(\n                pytz.timezone(\"UTC\")\n            )\n        )\n\n        current_track.set_duration(track_info[\"time\"])\n\n        return current_track\n\n    def parse_event(self, event: CloudEvent) -&gt; Track:\n        track = Track()\n        logger.info(\"Parsing event: %s\" % event)\n\n        track.set_artist(event.data[\"item.artist\"])\n        track.set_title(event.data[\"item.title\"])\n\n        event_time = isodate.parse_datetime(event[\"time\"])\n        if event[\"type\"] == \"ch.rabe.api.events.track.v1.trackStarted\":\n            track.set_starttime(event_time)\n        elif event[\"type\"] == \"ch.rabe.api.events.track.v1.trackFinished\":\n            # TODO consider using now() instead of event['time']\n            track.set_endtime(event_time)\n\n        if \"item.length\" in event.data:\n            track.set_duration(event.data[\"item.length\"])\n\n        logger.info(\"Track: %s\" % track)\n        return track\n</code></pre>"},{"location":"reference/input/observer/#input.observer.NonKlangbeckenInputObserver","title":"<code>NonKlangbeckenInputObserver</code>","text":"<p>             Bases: <code>InputObserver</code></p> <p>Observer for input not from klangbecken ie. w/o track information.</p> <p>Uses the show's name instead of the actual track infos</p> Source code in <code>nowplaying/input/observer.py</code> <pre><code>class NonKlangbeckenInputObserver(InputObserver):\n    \"\"\"Observer for input not from klangbecken ie. w/o track information.\n\n    Uses the show's name instead of the actual track infos\n    \"\"\"\n\n    def handles(self, event: CloudEvent) -&gt; bool:  # pragma: no coverage\n        \"\"\"Do not handle events yet.\n\n        TODO implement this method\n        TODO v3-prep call :meth:`handle_id` from here\n             (needs saemubox_id compat workaround)\n        TODO v3 remove call to :meth:`handle_id`:\n        \"\"\"\n        return False\n\n    def event(self, event: CloudEvent):  # pragma: no coverage\n        \"\"\"Do not handle events yet.\n\n        TODO implement this method\n        \"\"\"\n        super().event(event)\n\n    def handle_id(self, saemubox_id: int, event: CloudEvent = None):\n        if saemubox_id != self.previous_saemubox_id:\n            # If s\u00e4mubox changes, force a show update, this acts as\n            # a self-healing measurement in case the show web service provides\n            # nonsense ;)\n            self.show = self.showclient.get_show_info(True)\n\n        self.previous_saemubox_id = saemubox_id\n\n        # only handle non-Klangbecken\n        if saemubox_id != 1:\n            return True\n\n        return False\n\n    def handle(self, event: CloudEvent = None):\n        self.show = self.showclient.get_show_info()\n\n        # only handle if a new show has started\n        if self.show.uuid != self.previous_show_uuid:\n            logger.info(\"Show changed\")\n            self.track_handler.track_started(self.get_track_info())\n            self.previous_show_uuid = self.show.uuid\n\n    def get_track_info(self):\n        current_track = Track()\n\n        current_track.set_artist(DEFAULT_ARTIST)\n        current_track.set_title(DEFAULT_TITLE)\n\n        # Set the track's start/end time to the start/end time of the show\n        current_track.set_starttime(self.show.starttime)\n        current_track.set_endtime(self.show.endtime)\n\n        current_track.set_show(self.show)\n\n        return current_track\n</code></pre>"},{"location":"reference/input/observer/#input.observer.NonKlangbeckenInputObserver.event","title":"<code>event(event)</code>","text":"<p>Do not handle events yet.</p> <p>TODO implement this method</p> Source code in <code>nowplaying/input/observer.py</code> <pre><code>def event(self, event: CloudEvent):  # pragma: no coverage\n    \"\"\"Do not handle events yet.\n\n    TODO implement this method\n    \"\"\"\n    super().event(event)\n</code></pre>"},{"location":"reference/input/observer/#input.observer.NonKlangbeckenInputObserver.handles","title":"<code>handles(event)</code>","text":"<p>Do not handle events yet.</p> <p>TODO implement this method TODO v3-prep call :meth:<code>handle_id</code> from here      (needs saemubox_id compat workaround) TODO v3 remove call to :meth:<code>handle_id</code>:</p> Source code in <code>nowplaying/input/observer.py</code> <pre><code>def handles(self, event: CloudEvent) -&gt; bool:  # pragma: no coverage\n    \"\"\"Do not handle events yet.\n\n    TODO implement this method\n    TODO v3-prep call :meth:`handle_id` from here\n         (needs saemubox_id compat workaround)\n    TODO v3 remove call to :meth:`handle_id`:\n    \"\"\"\n    return False\n</code></pre>"},{"location":"reference/misc/saemubox/","title":"Misc","text":"<p>Implemets the legacy serial over ip interface for the saemubox.</p> <p>The other part of the implementation is the virtual-saemubox. Both parts are scheduled to be removed in the future using the built in api client in modern pathfinder versions.</p> <p>This file has a bunch of untested ignored branches.</p>"},{"location":"reference/misc/saemubox/#misc.saemubox.SaemuBox","title":"<code>SaemuBox</code>","text":"<p>Receive and validate info from S\u00e4mu Box for nowplaying.</p> Source code in <code>nowplaying/misc/saemubox.py</code> <pre><code>class SaemuBox:\n    \"\"\"Receive and validate info from S\u00e4mu Box for nowplaying.\"\"\"\n\n    output_mapping = {\n        1: \"Klangbecken\",\n        2: \"Live + Replay\",\n        3: \"Frei\",\n        4: \"Vorproduktion\",\n        5: \"H\u00f6rmal\",\n        6: \"Studio Live\",\n    }\n\n    def __init__(self, saemubox_ip, check_sender=True):\n        warnings.warn(\n            \"Saemubox will be replaced with Pathfinder\", PendingDeprecationWarning\n        )\n        self.output = \"\"\n\n        # listening ip adress (all)\n        self.bind_ip = \"0.0.0.0\"\n\n        # listening port\n        self.port = 4001\n\n        # allowed sender ip addresses\n        self.senders = {saemubox_ip}\n\n        # check self.senders for validity\n        self.check_sender = check_sender\n\n        # valid saemubox ids\n        self.valid_ids = [str(i) for i in self.output_mapping]\n\n    def run(self):  # pragma: no cover\n        self._setup_socket()\n        # wait for some data to arrive\n        time.sleep(0.2)\n\n    def _setup_socket(self):  # pragma: no cover\n        try:\n            self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n            self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n            self.sock.bind((self.bind_ip, self.port))\n            logger.info(\"SaemuBox: listening on %s:%i.\" % (self.bind_ip, self.port))\n        except OSError as e:  # pragma: no cover\n            self.sock = None\n            logger.error(\"SaemuBox: cannot bind to %s:%i.\" % (self.bind_ip, self.port))\n            raise SaemuBoxError() from e\n\n    def __update(self):  # pragma: no cover\n        if self.sock is None or (hasattr(self.sock, \"_closed\") and self.sock._closed):\n            logger.warn(\"SaemuBox: socket closed unexpectedly, retrying...\")\n            self._setup_socket()\n\n        output = None\n        seen_senders = set()\n\n        # read from socket while there is something to read (non-blocking)\n        while select.select([self.sock], [], [], 0)[0]:\n            data, addr = self.sock.recvfrom(1024)\n            if self.check_sender and addr[0] not in self.senders:\n                logger.warn(\"SaemuBox: receiving data from invalid host: %s \" % addr[0])\n                continue\n\n            ids = data.split()  # several saemubox ids might come in one packet\n            if ids:\n                id = ids[-1].decode(\"utf-8\")  # only take last id\n                if id in self.valid_ids:\n                    seen_senders.add(addr[0])\n                    output = id\n                else:\n                    logger.warn(\"SaemuBox: received invalid data: %s\" % data)\n\n        if output is None:\n            logger.error(\"SaemuBox: could not read current status.\")\n            output = 0\n            raise SaemuBoxError(\"Cannot read data from SaemuBox\")\n        elif seen_senders != self.senders:\n            for missing_sender in self.senders - seen_senders:\n                logger.warn(\"SaemuBox: missing sender: %s\" % missing_sender)\n\n        self.output = int(output)\n\n    def get_active_output_id(self):  # pragma: no cover\n        self.__update()\n        return self.output\n\n    def get_active_output_name(self):  # pragma: no cover\n        self.__update()\n        return self.output_mapping[self.output]\n\n    def get_id_as_name(self, number):  # pragma: no cover\n        return self.output_mapping[number]\n</code></pre>"},{"location":"reference/misc/saemubox/#misc.saemubox.SaemuBoxError","title":"<code>SaemuBoxError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>SaemuBox related exception.</p> Source code in <code>nowplaying/misc/saemubox.py</code> <pre><code>class SaemuBoxError(Exception):\n    \"\"\"SaemuBox related exception.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/show/client/","title":"Show","text":""},{"location":"reference/show/client/#show.client.ShowClient","title":"<code>ShowClient</code>","text":"<p>Fetches the show info from LibreTime now-playing v2 endpoint.</p> <p>Every show has a name, a start and endtime and an optional URL.</p> Source code in <code>nowplaying/show/client.py</code> <pre><code>class ShowClient:\n    \"\"\"Fetches the show info from LibreTime now-playing v2 endpoint.\n\n    Every show has a name, a start and endtime and an optional URL.\n    \"\"\"\n\n    __DEFAULT_SHOW_DURATION = 3  # 3 seconds\n    __cleanup_show_name_regexp = re.compile(r\"&amp;(\\w+?);\")\n    __show_datetime_format = \"%Y-%m-%d %H:%M:%S\"\n\n    def __init__(self, current_show_url):\n        self.current_show_url = current_show_url\n\n        self.show = Show()\n        self.showtz = None\n\n    def get_show_info(self, force_update=False):\n        \"\"\"Return a Show object.\"\"\"\n\n        if force_update:\n            self.update()\n        else:\n            self.lazy_update()\n\n        return self.show\n\n    def lazy_update(self):\n        # only update the info if we expect that a new show has started\n        if datetime.datetime.now(pytz.timezone(\"UTC\")) &gt; self.show.endtime:\n            logger.info(\"Show expired, going to update show info\")\n            self.update()\n\n        else:\n            logger.debug(\"Show still running, won't update show info\")\n\n    def update(self):\n        self.show = Show()  # Create a new show object\n\n        # Set the show's default end time to now + 30 seconds to prevent updates\n        # happening every second and hammering the web service if something\n        # goes wrong later.\n        self.show.set_endtime(\n            datetime.datetime.now(pytz.timezone(\"UTC\"))\n            + datetime.timedelta(seconds=self.__DEFAULT_SHOW_DURATION)\n        )\n\n        try:\n            # try to get the current show informations from loopy's cast web\n            # service\n            data = requests.get(self.current_show_url).json()\n\n            logger.debug(\"Got show info: %s\" % data)\n\n        except Exception as e:\n            logger.error(\"Unable to get current show informations\")\n\n            logger.exception(e)\n            # LSB 2017: ignoring missing show update\n            # raise ShowClientError('Unable to get show informations: %s' % e)\n            return\n\n        self.showtz = pytz.timezone(data[\"station\"][\"timezone\"])\n\n        # pick the current show\n        show_data = self.__pick_current_show(data)\n\n        if not show_data:\n            logger.warning(\"Failed to find a current or upcoming show, bailing out.\")\n            return\n\n        # get the name of the show, aka real_name\n        # ex.: Stereo Freeze\n        real_name = show_data[\"name\"]\n\n        if len(real_name) == 0:\n            # keep the default show information\n            logger.error(\"No show name found\")\n            raise ShowClientError(\"Missing show name\")\n\n        real_name = self.__cleanup_show_name(real_name)\n        self.show.set_name(real_name)\n\n        # get the show's end time in order to time the next lookup.\n        # ex.: 2012-04-28 19:00:00 (missing a tzoffset and localized!)\n        end_time = show_data[\"ends\"]\n\n        if len(end_time) == 0:\n            logger.error(\"No end found\")\n            raise ShowClientError(\"Missing show end time\")\n\n        endtime = self.showtz.localize(\n            datetime.datetime.strptime(end_time, self.__show_datetime_format)\n        )\n\n        # store as UTC datetime object\n        self.show.set_endtime(endtime.astimezone(pytz.timezone(\"UTC\")))\n\n        # get the show's start time\n        # ex.: 2012-04-28 18:00:00\n        start_time = show_data[\"starts\"]\n\n        if len(start_time) == 0:\n            logger.error(\"No start found\")\n            raise ShowClientError(\"Missing show start time\")\n\n        starttime = self.showtz.localize(\n            datetime.datetime.strptime(start_time, self.__show_datetime_format)\n        )\n\n        # store as UTC datetime object\n        self.show.set_starttime(starttime.astimezone(pytz.timezone(\"UTC\")))\n\n        # Check if the endtime is in the past\n        # This prevents stale (wrong) show informations from beeing pushed to\n        # the live stream and stops hammering the service every second\n        if self.show.endtime &lt; datetime.datetime.now(pytz.timezone(\"UTC\")):\n            logger.error(\"Show endtime %s is in the past\" % self.show.endtime)\n\n            raise ShowClientError(\n                \"Show end time (%s) is in the past\" % self.show.endtime\n            )\n\n        # get the show's URL\n        # ex.: http://www.rabe.ch/sendungen/entertainment/onda-libera.html\n        url = show_data[\"url\"]\n\n        if len(url) == 0:\n            logger.error(\"No url found\")\n        else:\n            self.show.set_url(url)\n\n        logger.info(\n            'Show \"%s\" started and runs from %s till %s'\n            % (self.show.name, starttime, endtime)\n        )\n        logger.debug(self.show)\n\n    def __cleanup_show_name(self, name) -&gt; str:\n        \"\"\"Cleanup name by undoing htmlspecialchars from libretime zf1 mvc.\"\"\"\n\n        def __entityref_decode(m):\n            try:\n                return entitydefs[m.group(1)]\n            except KeyError:\n                return m.group(0)\n\n        return self.__cleanup_show_name_regexp.sub(__entityref_decode, name)\n\n    def __pick_current_show(self, data):\n        \"\"\"Pick the current show from the data.\n\n        If there is no current show and the next one starts reasonably soon, pick that.\n        \"\"\"\n        if not data[\"shows\"][\"current\"]:\n            # ignore if no current show is playing\n            logger.info(\"No current show is playing, checking next show\")\n            if data[\"shows\"][\"next\"] and data[\"shows\"][\"next\"][0]:\n                show = data[\"shows\"][\"next\"][0]\n                logger.info(\"Next show is %s\" % show[\"name\"])\n                next_start = self.showtz.localize(\n                    datetime.datetime.strptime(\n                        show[\"starts\"], self.__show_datetime_format\n                    )\n                )\n                logger.warning(\n                    datetime.datetime.now(pytz.timezone(\"UTC\"))\n                    + datetime.timedelta(minutes=15)\n                )\n                logger.warning(next_start)\n                if next_start &lt; datetime.datetime.now(\n                    pytz.timezone(\"UTC\")\n                ) + datetime.timedelta(minutes=15):\n                    logger.info(\"Next show starts soon enough, using it\")\n                    return show\n            return\n        return data[\"shows\"][\"current\"]\n</code></pre>"},{"location":"reference/show/client/#show.client.ShowClient.__cleanup_show_name","title":"<code>__cleanup_show_name(name)</code>","text":"<p>Cleanup name by undoing htmlspecialchars from libretime zf1 mvc.</p> Source code in <code>nowplaying/show/client.py</code> <pre><code>def __cleanup_show_name(self, name) -&gt; str:\n    \"\"\"Cleanup name by undoing htmlspecialchars from libretime zf1 mvc.\"\"\"\n\n    def __entityref_decode(m):\n        try:\n            return entitydefs[m.group(1)]\n        except KeyError:\n            return m.group(0)\n\n    return self.__cleanup_show_name_regexp.sub(__entityref_decode, name)\n</code></pre>"},{"location":"reference/show/client/#show.client.ShowClient.__pick_current_show","title":"<code>__pick_current_show(data)</code>","text":"<p>Pick the current show from the data.</p> <p>If there is no current show and the next one starts reasonably soon, pick that.</p> Source code in <code>nowplaying/show/client.py</code> <pre><code>def __pick_current_show(self, data):\n    \"\"\"Pick the current show from the data.\n\n    If there is no current show and the next one starts reasonably soon, pick that.\n    \"\"\"\n    if not data[\"shows\"][\"current\"]:\n        # ignore if no current show is playing\n        logger.info(\"No current show is playing, checking next show\")\n        if data[\"shows\"][\"next\"] and data[\"shows\"][\"next\"][0]:\n            show = data[\"shows\"][\"next\"][0]\n            logger.info(\"Next show is %s\" % show[\"name\"])\n            next_start = self.showtz.localize(\n                datetime.datetime.strptime(\n                    show[\"starts\"], self.__show_datetime_format\n                )\n            )\n            logger.warning(\n                datetime.datetime.now(pytz.timezone(\"UTC\"))\n                + datetime.timedelta(minutes=15)\n            )\n            logger.warning(next_start)\n            if next_start &lt; datetime.datetime.now(\n                pytz.timezone(\"UTC\")\n            ) + datetime.timedelta(minutes=15):\n                logger.info(\"Next show starts soon enough, using it\")\n                return show\n        return\n    return data[\"shows\"][\"current\"]\n</code></pre>"},{"location":"reference/show/client/#show.client.ShowClient.get_show_info","title":"<code>get_show_info(force_update=False)</code>","text":"<p>Return a Show object.</p> Source code in <code>nowplaying/show/client.py</code> <pre><code>def get_show_info(self, force_update=False):\n    \"\"\"Return a Show object.\"\"\"\n\n    if force_update:\n        self.update()\n    else:\n        self.lazy_update()\n\n    return self.show\n</code></pre>"},{"location":"reference/show/client/#show.client.ShowClientError","title":"<code>ShowClientError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>ShowClient related exception.</p> Source code in <code>nowplaying/show/client.py</code> <pre><code>class ShowClientError(Exception):\n    \"\"\"ShowClient related exception.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/show/show/","title":"Show","text":""},{"location":"reference/show/show/#show.show.Show","title":"<code>Show</code>","text":"<p>Show object which has a start and end time and an optional URL.</p> Source code in <code>nowplaying/show/show.py</code> <pre><code>class Show:\n    \"\"\"Show object which has a start and end time and an optional URL.\"\"\"\n\n    def __init__(self):\n        self.name = \"\"\n\n        self.url = DEFAULT_SHOW_URL\n\n        # The show's global unique identifier\n        self.uuid = str(uuid.uuid4())\n\n        # Get current datetime object in UTC timezone\n        now = datetime.datetime.now(pytz.timezone(\"UTC\"))\n\n        # The show's start time, initially set to now\n        self.starttime = now\n\n        # The show's end time, initially set to to now\n        self.endtime = now\n\n    def set_name(self, name):\n        # The name of the show\n        self.name = name\n\n    def set_url(self, url):\n        # The URL of the show\n        self.url = url\n\n    def set_starttime(self, starttime):\n        if not isinstance(starttime, datetime.datetime):\n            raise ShowError(\"starttime has to be a datatime object\")\n\n        # The show's start time as a datetime object\n        self.starttime = starttime\n\n    def set_endtime(self, endtime):\n        if not isinstance(endtime, datetime.datetime):\n            raise ShowError(\"endtime has to be a datatime object\")\n\n        # The show's end time as a datetime object\n        self.endtime = endtime\n\n    def __str__(self):\n        return (\n            f\"Show '{self.name}' ({self.uuid}), \"\n            f\"start: '{self.starttime}', end: '{self.endtime}', url: {self.url}\"\n        )\n</code></pre>"},{"location":"reference/show/show/#show.show.ShowError","title":"<code>ShowError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Show related exception.</p> Source code in <code>nowplaying/show/show.py</code> <pre><code>class ShowError(Exception):\n    \"\"\"Show related exception.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/track/handler/","title":"Track","text":"<p>Track event handling subject of the observer.</p>"},{"location":"reference/track/handler/#track.handler.TrackEventHandler","title":"<code>TrackEventHandler</code>","text":"<p>Inform all registered track-event observers about a track change.</p> <p>This is the subject of the classical observer pattern</p> Source code in <code>nowplaying/track/handler.py</code> <pre><code>class TrackEventHandler:\n    \"\"\"Inform all registered track-event observers about a track change.\n\n    This is the subject of the classical observer pattern\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the track event handler.\"\"\"\n        self.__observers = []\n\n    def register_observer(self, observer: TrackObserver):\n        \"\"\"Register an observer to be informed about track changes.\"\"\"\n        logger.info(\"Registering TrackObserver '%s'\", observer.__class__.__name__)\n        self.__observers.append(observer)\n\n    def remove_observer(self, observer: TrackObserver):\n        \"\"\"Remove an observer from the list of observers.\"\"\"\n        self.__observers.remove(observer)\n\n    def get_observers(self) -&gt; list:\n        \"\"\"Return register observers to allow inspecting them.\"\"\"\n        return self.__observers\n\n    def track_started(self, track: Track):\n        \"\"\"Inform all registered track-event observers about a track started event.\"\"\"\n        logger.info(\n            \"Sending track-started event to %s observers: %s\",\n            len(self.__observers),\n            track,\n        )\n\n        for observer in self.__observers:\n            logger.debug(\n                \"Sending track-started event to observer %s\", observer.__class__\n            )\n\n            try:\n                observer.track_started(track)\n            except Exception as error:\n                logger.exception(error)\n\n    def track_finished(self, track: Track):\n        \"\"\"Inform all registered track-event observers about a track finished event.\"\"\"\n        logger.info(\n            \"Sending track-finished event to %s observers: %s\",\n            len(self.__observers),\n            track,\n        )\n\n        for observer in self.__observers:\n            logger.debug(\n                \"Sending track-finished event to observer %s\", observer.__class__\n            )\n\n            try:\n                observer.track_finished(track)\n            except Exception as error:\n                logger.exception(error)\n</code></pre>"},{"location":"reference/track/handler/#track.handler.TrackEventHandler.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the track event handler.</p> Source code in <code>nowplaying/track/handler.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the track event handler.\"\"\"\n    self.__observers = []\n</code></pre>"},{"location":"reference/track/handler/#track.handler.TrackEventHandler.get_observers","title":"<code>get_observers()</code>","text":"<p>Return register observers to allow inspecting them.</p> Source code in <code>nowplaying/track/handler.py</code> <pre><code>def get_observers(self) -&gt; list:\n    \"\"\"Return register observers to allow inspecting them.\"\"\"\n    return self.__observers\n</code></pre>"},{"location":"reference/track/handler/#track.handler.TrackEventHandler.register_observer","title":"<code>register_observer(observer)</code>","text":"<p>Register an observer to be informed about track changes.</p> Source code in <code>nowplaying/track/handler.py</code> <pre><code>def register_observer(self, observer: TrackObserver):\n    \"\"\"Register an observer to be informed about track changes.\"\"\"\n    logger.info(\"Registering TrackObserver '%s'\", observer.__class__.__name__)\n    self.__observers.append(observer)\n</code></pre>"},{"location":"reference/track/handler/#track.handler.TrackEventHandler.remove_observer","title":"<code>remove_observer(observer)</code>","text":"<p>Remove an observer from the list of observers.</p> Source code in <code>nowplaying/track/handler.py</code> <pre><code>def remove_observer(self, observer: TrackObserver):\n    \"\"\"Remove an observer from the list of observers.\"\"\"\n    self.__observers.remove(observer)\n</code></pre>"},{"location":"reference/track/handler/#track.handler.TrackEventHandler.track_finished","title":"<code>track_finished(track)</code>","text":"<p>Inform all registered track-event observers about a track finished event.</p> Source code in <code>nowplaying/track/handler.py</code> <pre><code>def track_finished(self, track: Track):\n    \"\"\"Inform all registered track-event observers about a track finished event.\"\"\"\n    logger.info(\n        \"Sending track-finished event to %s observers: %s\",\n        len(self.__observers),\n        track,\n    )\n\n    for observer in self.__observers:\n        logger.debug(\n            \"Sending track-finished event to observer %s\", observer.__class__\n        )\n\n        try:\n            observer.track_finished(track)\n        except Exception as error:\n            logger.exception(error)\n</code></pre>"},{"location":"reference/track/handler/#track.handler.TrackEventHandler.track_started","title":"<code>track_started(track)</code>","text":"<p>Inform all registered track-event observers about a track started event.</p> Source code in <code>nowplaying/track/handler.py</code> <pre><code>def track_started(self, track: Track):\n    \"\"\"Inform all registered track-event observers about a track started event.\"\"\"\n    logger.info(\n        \"Sending track-started event to %s observers: %s\",\n        len(self.__observers),\n        track,\n    )\n\n    for observer in self.__observers:\n        logger.debug(\n            \"Sending track-started event to observer %s\", observer.__class__\n        )\n\n        try:\n            observer.track_started(track)\n        except Exception as error:\n            logger.exception(error)\n</code></pre>"},{"location":"reference/track/track/","title":"Track","text":""},{"location":"reference/track/track/#track.track.Track","title":"<code>Track</code>","text":"<p>Track object which has a start and end time and a related show.</p> Source code in <code>nowplaying/track/track.py</code> <pre><code>class Track:\n    \"\"\"Track object which has a start and end time and a related show.\"\"\"\n\n    def __init__(self):\n        self.artist = None\n\n        self.title = None\n\n        self.album = None\n\n        self.track = 1\n\n        # The track's global unique identifier\n        self.uuid = str(uuid.uuid4())\n\n        # Get current datetime object in UTC timezone\n        now = datetime.datetime.now(pytz.timezone(\"UTC\"))\n\n        # The show's start time, initially set to now\n        self.starttime = now\n\n        # The show's end time, initially set to to now\n        self.endtime = now\n\n    def set_artist(self, artist):\n        self.artist = artist\n\n    def set_title(self, title):\n        self.title = title\n\n    def set_album(self, album):\n        self.album = album\n\n    def set_track(self, track):\n        if track &lt; 0:\n            raise TrackError(\"track number has to be a positive integer\")\n\n        self.track = track\n\n    def set_starttime(self, starttime):\n        if not isinstance(starttime, datetime.datetime):\n            raise TrackError(\"starttime has to be a datatime object\")\n\n        # The track's start time as a datetime object\n        self.starttime = starttime\n\n    def set_endtime(self, endtime):\n        if not isinstance(endtime, datetime.datetime):\n            raise TrackError(\"endtime has to be a datatime object\")\n\n        # The track's end time as a datetime object\n        self.endtime = endtime\n\n    def set_duration(self, seconds):\n        self.endtime = self.starttime + datetime.timedelta(seconds=int(seconds))\n\n    def set_show(self, show):\n        # if not isinstance(show, show.Show):\n        #    raise TrackError('show has to be a Show object')\n\n        # The show which the track is related to\n        self.show = show\n\n    def get_duration(self):\n        return self.endtime - self.starttime\n\n    def has_default_artist(self):\n        if self.artist == DEFAULT_ARTIST:\n            return True\n\n        return False\n\n    def has_default_title(self):\n        if self.title == DEFAULT_TITLE:\n            return True\n\n        return False\n\n    def __str__(self):\n        return (\n            f\"Track '{self.artist}' - '{self.title}', \"\n            f\"start: '{self.starttime}', end: '{self.endtime}', uid: {self.uuid}\"\n        )\n</code></pre>"},{"location":"reference/track/track/#track.track.TrackError","title":"<code>TrackError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Track related exception.</p> Source code in <code>nowplaying/track/track.py</code> <pre><code>class TrackError(Exception):\n    \"\"\"Track related exception.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/track/observers/base/","title":"Observers","text":""},{"location":"reference/track/observers/base/#track.observers.base.TrackObserver","title":"<code>TrackObserver</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Abstract base class for all TrackObservers.</p> Source code in <code>nowplaying/track/observers/base.py</code> <pre><code>class TrackObserver(ABC):\n    \"\"\"Abstract base class for all TrackObservers.\"\"\"\n\n    name = \"TrackObserver\"\n\n    class Options(ABC):\n        @classmethod\n        @abstractmethod\n        def args(cls, args: configargparse.ArgParser) -&gt; None:  # pragma: no cover\n            pass\n\n    def get_name(self):\n        return self.name\n\n    @abstractmethod\n    def track_started(self, track):  # pragma: no cover\n        pass\n\n    @abstractmethod\n    def track_finished(self, track):  # pragma: no cover\n        pass\n</code></pre>"},{"location":"reference/track/observers/dab_audio_companion/","title":"Dab audio companion","text":""},{"location":"reference/track/observers/dab_audio_companion/#track.observers.dab_audio_companion.DabAudioCompanionTrackObserver","title":"<code>DabAudioCompanionTrackObserver</code>","text":"<p>             Bases: <code>TrackObserver</code></p> <p>Update track data in a DAB+ transmission through the 'Audio Companion' API.</p> Source code in <code>nowplaying/track/observers/dab_audio_companion.py</code> <pre><code>class DabAudioCompanionTrackObserver(TrackObserver):\n    \"\"\"Update track data in a DAB+ transmission through the 'Audio Companion' API.\"\"\"\n\n    name = \"DAB+ Audio Companion\"\n\n    class Options(TrackObserver.Options):  # pragma: no coverage\n        @classmethod\n        def args(cls, args: configargparse.ArgParser):\n            args.add_argument(\n                \"-d\",\n                \"--dab\",\n                action=\"append\",\n                help=\"DAB audio companion base URL, allowed multiple times (ie. http://dab.example.org:8080)\",\n                default=[],\n            )\n            # TODO v3 remove when stable\n            args.add_argument(\n                \"--dab-send-dls\",\n                type=bool,\n                nargs=\"?\",\n                dest=\"dab_send_dls\",\n                help=\"Send artist/title to DAB companions dls endpoint (default: True)\",\n                default=True,\n            )\n\n        def __init__(self, url: str, dl_plus: bool = True) -&gt; None:\n            self.url: str = url\n            self.dl_plus: bool = dl_plus\n\n    def __init__(self, options: Options):\n        self._options = options\n        self.base_url = options.url + \"/api/setDLS\"\n        self.dls_enabled = self.last_frame_was_dl_plus = self._options.dl_plus\n        logger.info(\n            \"DAB+ Audio Companion initialised with URL: %s, DLS+ enabled: %r\"\n            % (self.base_url, self.dls_enabled)\n        )\n\n    def track_started(self, track: Track):\n        logger.info(f\"Updating DAB+ DLS for track: {track.artist} - {track.title}\")\n        # TODO v3 remove _track_started_plain\n        if not self.dls_enabled:\n            return self._track_started_plain(track)\n\n        params = {}\n\n        if track.get_duration() &lt; timedelta(seconds=5):\n            logger.info(\n                \"Track is less than 5 seconds, not sending to DAB+ Audio Companion\"\n            )\n            return\n\n        if not track.has_default_title() and not track.has_default_artist():\n            params[\"artist\"] = track.artist\n            params[\"title\"] = track.title\n            self.last_frame_was_dl_plus = True\n        elif self.last_frame_was_dl_plus:\n            logger.info(\n                \"Track has default info, using show instead. Sending DLS+ delete tags.\"\n            )\n            message = DLPlusMessage()\n            # track.artist contains station name if no artist is set\n            message.add_dlp_object(DLPlusObject(\"STATIONNAME.LONG\", track.artist))\n            # TODO complete integration w/o f-string\n            #      PROGAMME.NOW for show name needs a carousel + deleting\n            # message.add_dlp_object(DLPlusObject(\"PROGRAMME.NOW\", track.show.name))\n            message.add_dlp_object(DLPlusObject(\"ITEM.TITLE\", delete=True))\n            message.add_dlp_object(DLPlusObject(\"ITEM.ARTIST\", delete=True))\n            message.build(f\"$STATIONNAME.LONG - {track.show.name}\")\n            params[\"dls\"] = str(ODRPadEncRenderer(message))\n            self.last_frame_was_dl_plus = False\n        else:\n            logger.info(\"Track has default info, using show instead\")\n            # track.artist contains station name if no artist is set\n            params[\"dls\"] = f\"{track.artist} - {track.show.name}\"\n\n        logger.info(\n            f\"DAB+ Audio Companion URL: {self.base_url} \"\n            f\"data: {params} is DL+: {self.last_frame_was_dl_plus}\"\n        )\n\n        resp = requests.post(self.base_url, params)\n        if resp.status_code != 200:\n            logger.error(f\"DAB+ Audio Companion API call failed: {resp.text}\")\n\n    def _track_started_plain(self, track):\n        # TODO v3 remove once we always send DLS with v3\n        title = track.title\n\n        if track.has_default_title() and track.has_default_artist():\n            logger.info(\n                \"%s: Track has default info, using show instead\" % self.__class__\n            )\n\n            title = track.show.name\n\n        # artist is an unicode string which we have to encode into UTF-8\n        # http://bugs.python.org/issue216716\n        song_string = urllib.parse.quote_plus(\n            f\"{track.artist.encode('utf8')} - {title.encode('utf8')}\"\n        )\n\n        update_url = f\"{self.base_url}?dls={song_string}\"\n\n        logger.info(\"DAB+ Audio Companion URL: \" + update_url)\n\n        urllib.request.urlopen(update_url)\n\n    def track_finished(self, track):\n        return True\n</code></pre>"},{"location":"reference/track/observers/icecast/","title":"Icecast","text":""},{"location":"reference/track/observers/icecast/#track.observers.icecast.IcecastTrackObserver","title":"<code>IcecastTrackObserver</code>","text":"<p>             Bases: <code>TrackObserver</code></p> <p>Update track metadata on an icecast mountpoint.</p> Source code in <code>nowplaying/track/observers/icecast.py</code> <pre><code>class IcecastTrackObserver(TrackObserver):\n    \"\"\"Update track metadata on an icecast mountpoint.\"\"\"\n\n    name = \"Icecast\"\n\n    class Options(TrackObserver.Options):\n        \"\"\"IcecastTrackObserver options.\"\"\"\n\n        @classmethod\n        def args(cls, args: configargparse.ArgParser) -&gt; None:\n            # TODO v3 remove this option\n            args.add_argument(\n                \"-m\",\n                \"--icecast-base\",\n                dest=\"icecastBase\",\n                help=\"Icecast base URL\",\n                default=\"http://icecast.example.org:8000/admin/\",\n            )\n            # TODO v3 remove this option\n            args.add_argument(\n                \"--icecast-password\", dest=\"icecastPassword\", help=\"Icecast Password\"\n            )\n            args.add_argument(\n                \"-i\",\n                \"--icecast\",\n                action=\"append\",\n                help=\"\"\"Icecast endpoints, allowed multiple times. nowplaying\n                will send metadata updates to each of the configured endpoints.\n                Specify complete connection data like username and password in\n                the URLs e.g. 'http://source:changeme@icecast.example.org:8000/admin/metadata.xsl?mount=/radio'.\"\"\",\n                default=[],\n            )\n\n        def __init__(\n            self,\n            url: str,\n            username: str | None = None,\n            password: str | None = None,\n            mount: str | None = None,\n        ):\n            # TODO v3 remove optional args and only support parsed URLs\n            (self.url, self.username, self.password, self.mount) = parse_icecast_url(\n                url\n            )\n            # TODO v3 remove non URL usage of username, password, ...\n            if not self.username and username:\n                # grab from args if not in URL\n                logger.warning(\"deprecated use username from URL\")\n                self.username = username\n            if not self.username:\n                # default to source if neither in URL nor args\n                logger.warning(\"deprecated use username from URL\")\n                self.username = \"source\"\n            if not self.password and password:\n                # grab from args if not in URL\n                logger.warning(\"deprecated use password from URL\")\n                self.password = password\n            if not self.mount and mount:\n                # grab from args if not in URL\n                logger.warning(\"deprecated use mount from URL\")\n                self.mount = mount\n            if not self.password:\n                raise ValueError(\"Missing required parameter password for %s\" % url)\n            if not self.mount:\n                raise ValueError(\"Missing required parameter mount for %s\" % url)\n\n    def __init__(self, options: Options):\n        self.options = options\n        logger.info(f\"Icecast URL: {self.options.url} mount: {self.options.mount}\")\n\n    def track_started(self, track: Track):\n        logger.info(\n            f\"Updating Icecast Metadata for track: {track.artist} - {track.title}\"\n        )\n\n        title = track.title\n\n        if track.has_default_title() and track.has_default_artist():\n            logger.info(\"Track has default info, using show instead\")\n\n            title = track.show.name\n\n        params = {\n            \"mount\": self.options.mount,\n            \"mode\": \"updinfo\",\n            \"charset\": \"utf-8\",\n            \"song\": f\"{track.artist} - {title}\",\n        }\n        try:\n            requests.get(\n                self.options.url,\n                auth=(self.options.username, self.options.password),\n                params=params,\n            )\n        except requests.exceptions.RequestException as e:\n            logger.exception(e)\n\n        logger.info(\n            f\"Icecast Metadata updated on {self.options.url} with data: {params}\"\n        )\n\n    def track_finished(self, track):\n        return True\n</code></pre>"},{"location":"reference/track/observers/icecast/#track.observers.icecast.IcecastTrackObserver.Options","title":"<code>Options</code>","text":"<p>             Bases: <code>Options</code></p> <p>IcecastTrackObserver options.</p> Source code in <code>nowplaying/track/observers/icecast.py</code> <pre><code>class Options(TrackObserver.Options):\n    \"\"\"IcecastTrackObserver options.\"\"\"\n\n    @classmethod\n    def args(cls, args: configargparse.ArgParser) -&gt; None:\n        # TODO v3 remove this option\n        args.add_argument(\n            \"-m\",\n            \"--icecast-base\",\n            dest=\"icecastBase\",\n            help=\"Icecast base URL\",\n            default=\"http://icecast.example.org:8000/admin/\",\n        )\n        # TODO v3 remove this option\n        args.add_argument(\n            \"--icecast-password\", dest=\"icecastPassword\", help=\"Icecast Password\"\n        )\n        args.add_argument(\n            \"-i\",\n            \"--icecast\",\n            action=\"append\",\n            help=\"\"\"Icecast endpoints, allowed multiple times. nowplaying\n            will send metadata updates to each of the configured endpoints.\n            Specify complete connection data like username and password in\n            the URLs e.g. 'http://source:changeme@icecast.example.org:8000/admin/metadata.xsl?mount=/radio'.\"\"\",\n            default=[],\n        )\n\n    def __init__(\n        self,\n        url: str,\n        username: str | None = None,\n        password: str | None = None,\n        mount: str | None = None,\n    ):\n        # TODO v3 remove optional args and only support parsed URLs\n        (self.url, self.username, self.password, self.mount) = parse_icecast_url(\n            url\n        )\n        # TODO v3 remove non URL usage of username, password, ...\n        if not self.username and username:\n            # grab from args if not in URL\n            logger.warning(\"deprecated use username from URL\")\n            self.username = username\n        if not self.username:\n            # default to source if neither in URL nor args\n            logger.warning(\"deprecated use username from URL\")\n            self.username = \"source\"\n        if not self.password and password:\n            # grab from args if not in URL\n            logger.warning(\"deprecated use password from URL\")\n            self.password = password\n        if not self.mount and mount:\n            # grab from args if not in URL\n            logger.warning(\"deprecated use mount from URL\")\n            self.mount = mount\n        if not self.password:\n            raise ValueError(\"Missing required parameter password for %s\" % url)\n        if not self.mount:\n            raise ValueError(\"Missing required parameter mount for %s\" % url)\n</code></pre>"},{"location":"reference/track/observers/scrobbler/","title":"Scrobbler","text":""},{"location":"reference/track/observers/scrobbler/#track.observers.scrobbler.ScrobblerTrackObserver","title":"<code>ScrobblerTrackObserver</code>","text":"<p>             Bases: <code>TrackObserver</code></p> <p>Scrobble track information to last.fm and libre.fm.</p> Source code in <code>nowplaying/track/observers/scrobbler.py</code> <pre><code>class ScrobblerTrackObserver(TrackObserver):  # pragma: no cover\n    \"\"\"Scrobble track information to last.fm and libre.fm.\"\"\"\n\n    name = \"Audioscrobbler\"\n\n    lastfm_api_key = \"\"\n    lastfm_api_secret = \"\"\n\n    librefm_api_key = \"\"\n    librefm_api_secret = \"\"\n\n    def __init__(self, user, password):\n        raise Exception(\"Unmaintained ScrobblerTrackObserver called\")\n\n        password = pylast.md5(password)\n\n        self.lastfm = pylast.get_lastfm_network(\"\", \"\", None, user, password)\n        self.librefm = pylast.get_librefm_network(\"\", \"\", None, user, password)\n\n        self.scrobblers = {\n            \"lastfm\": self.lastfm.get_scrobbler(\"tst\", \"1.0\"),\n            \"librefm\": self.librefm.get_scrobbler(\"tst\", \"1.0\"),\n        }\n\n    def track_started(self, track):\n        if track.has_default_artist() or track.has_default_title():\n            logger.error(\"Default artist or title, skip now-playing scrobble\")\n            return False\n\n        logger.info(\n            \"AS now-playing notification for track: %s - %s\"\n            % (track.artist, track.title)\n        )\n\n        # scrobble to all networks\n        #\n        # Note that track.get_duration() returns a timedelta object, which\n        # could (theoretically) also contain minutes, hours and days, however\n        # the track.set_duration() method only accepts seconds, therefore it's\n        # safe to read track.get_duration().seconds. Python 2.7 will bring the\n        # proper solution with its timedelta.total_seconds() method.\n        for k, scrobbler in self.scrobblers.items():\n            scrobbler.report_now_playing(\n                track.artist,\n                track.title,\n                track.album,\n                str(track.get_duration().seconds),\n                str(track.track),\n            )\n\n    def track_finished(self, track):\n        logger.info(\"Track duration was: %s\" % track.get_duration().seconds)\n\n        # if track.get_duration() &lt; datetime.timedelta(seconds=30):\n        if track.get_duration().seconds &lt; 30:\n            # respecting last.fm minimum song lenght policy of 30 seconds\n            logger.info(\"Track duration is &lt; 30s, skip scrobble submit\")\n            return False\n\n        if track.has_default_artist() or track.has_default_title():\n            logger.error(\"Default artist or title, skip scrobble submit\")\n            return False\n\n        logger.info(f\"AS submit for track: {track.artist} - {track.title}\")\n\n        # Get UTC unix timestamp without daylight saving informations\n        # http://stackoverflow.com/questions/1077285/how-to-specify-time-zone-utc-when-converting-to-unix-time-python\n        timestamp = calendar.timegm(track.starttime.utctimetuple())\n\n        # scrobbling to all networks\n        #\n        # Note that track.get_duration() returns a timedelta object, which\n        # could (theoretically) also contain minutes, hours and days, however\n        # the track.set_duration() method only accepts seconds, therefore it's\n        # safe to read track.get_duration().seconds. Python 2.7 will bring the\n        # proper solution with its timedelta.total_seconds() method.\n        for k, scrobbler in self.scrobblers.items():\n            scrobbler.scrobble(\n                track.artist,\n                track.title,\n                int(timestamp),\n                \"P\",\n                \"\",\n                str(track.get_duration().seconds),\n                track.album,\n                str(track.track),\n            )\n</code></pre>"},{"location":"reference/track/observers/smc_ftp/","title":"Smc ftp","text":""},{"location":"reference/track/observers/smc_ftp/#track.observers.smc_ftp.SmcFtpTrackObserver","title":"<code>SmcFtpTrackObserver</code>","text":"<p>             Bases: <code>TrackObserver</code></p> <p>Update track metadata for DLS and DL+ to the SMC FTP server.</p> Source code in <code>nowplaying/track/observers/smc_ftp.py</code> <pre><code>class SmcFtpTrackObserver(TrackObserver):\n    \"\"\"Update track metadata for DLS and DL+ to the SMC FTP server.\"\"\"\n\n    name = \"SMC FTP\"\n\n    class Options(TrackObserver.Options):  # pragma: no coverage\n        @classmethod\n        def args(cls, args: configargparse.ArgParser):\n            args.add_argument(\n                \"--dab-smc\",\n                help=\"Enable SMC FTP delivery\",\n                type=bool,\n                default=False,\n            )\n            args.add_argument(\n                \"--dab-smc-ftp-hostname\",\n                help=\"Hostname of SMC FTP server\",\n                default=[],\n            )\n            args.add_argument(\n                \"--dab-smc-ftp-username\",\n                help=\"Username for SMC FTP server\",\n            )\n            args.add_argument(\n                \"--dab-smc-ftp-password\", help=\"Password for SMC FTP server\"\n            )\n\n        def __init__(self, hostname: str, username: str, password: str) -&gt; None:\n            self.hostname: str = hostname\n            self.username: str = username\n            self.password: str = password\n\n    def __init__(self, options: Options):\n        self._options = options\n\n    def track_started(self, track: Track):\n        logger.info(f\"Updating DAB+ DLS for track {track.artist=} {track.title=}\")\n\n        if track.get_duration() &lt; timedelta(seconds=5):\n            logger.info(\n                \"Track is less than 5 seconds, not sending to SMC\"\n                f\"{track.artist=} {track.title=}\"\n            )\n            return\n\n        dls, dlplus = _dls_from_track(track)\n\n        # check for too long meta and shorten to just artist\n        if dls.getbuffer().nbytes &gt; 128:  # pragma: no cover\n            logger.warning(f\"SMC DLS to long {dls.getvalue().decode('latin1')=}\")\n            dls, dlplus = _dls_from_track(track, title=False)\n\n        ftp = FTP_TLS()\n        ftp.connect(self._options.hostname)\n        ftp.sendcmd(f\"USER {self._options.username}\")\n        ftp.sendcmd(f\"PASS {self._options.password}\")\n\n        ftp.storlines(\"STOR /dls/nowplaying.dls\", dls)\n        ftp.storlines(\"STOR /dlplus/nowplaying.dls\", dlplus)\n\n        ftp.quit()\n        ftp.close()\n\n        logger.info(\n            f\"SMC FTP {self._options.hostname=} \"\n            f\"{dls.getvalue().decode('latin1')=} \"\n            f\"{dlplus.getvalue().decode('latin1')=}\"\n        )\n\n    def track_finished(self, track):\n        return True\n</code></pre>"},{"location":"reference/track/observers/ticker/","title":"Ticker","text":""},{"location":"reference/track/observers/ticker/#track.observers.ticker.TickerTrackObserver","title":"<code>TickerTrackObserver</code>","text":"<p>             Bases: <code>TrackObserver</code></p> <p>Writes the new ticker feed file.</p> <p>The feed file will be consumed by the song-ticker on the RaBe website. This is the successor of the long gone PseudoRssTrackObserver format used by the pre-WordPress website. This version here gets consumed by the WordPress website.</p> Source code in <code>nowplaying/track/observers/ticker.py</code> <pre><code>class TickerTrackObserver(TrackObserver):\n    \"\"\"Writes the new ticker feed file.\n\n    The feed file will be consumed by the song-ticker on the RaBe website. This is the\n    successor of the long gone PseudoRssTrackObserver format used by the pre-WordPress\n    website. This version here gets consumed by the WordPress website.\n    \"\"\"\n\n    name = \"Ticker\"\n\n    class Options(TrackObserver.Options):\n        \"\"\"TickerTrackObserver options.\"\"\"\n\n        @classmethod\n        def args(cls, args: configargparse.ArgParser) -&gt; None:\n            args.add_argument(\n                \"--xml-output\",\n                dest=\"tickerOutputFile\",\n                help=\"ticker XML output format\",\n                default=\"/var/www/localhost/htdocs/songticker/0.9.3/current.xml\",\n            )\n\n        def __init__(self, file_path: str):\n            self.file_path = file_path\n\n    def __init__(self, options: Options):\n        warnings.warn(\n            \"The XML ticker format will be replaced with a JSON variant in the future\",\n            PendingDeprecationWarning,\n        )\n        self.ticker_file_path = options.file_path\n\n    def track_started(self, track):\n        logger.info(\n            f\"Updating Ticker XML file for track: {track.artist} - {track.title}\"\n        )\n        try:\n            tz = pytz.timezone(\"Europe/Zurich\")\n        except (\n            pytz.exceptions.UnknownTimeZoneError\n        ):  # pragma: no coverage due to not knowing how to trigger\n            tz = pytz.timezone(\"UTC\")\n\n        now = isodate.datetime_isoformat(datetime.datetime.now(tz))\n\n        MAIN_NAMESPACE = \"http://rabe.ch/schema/ticker.xsd\"\n        XLINK_NAMESPACE = \"http://www.w3.org/1999/xlink\"\n        XLINK = \"{%s}\" % XLINK_NAMESPACE\n\n        E = lxml.builder.ElementMaker(\n            namespace=MAIN_NAMESPACE,\n            nsmap={None: MAIN_NAMESPACE, \"xlink\": XLINK_NAMESPACE},\n        )\n        show_ref = E.link(track.show.url)\n        show_ref.attrib[XLINK + \"type\"] = \"simple\"\n        show_ref.attrib[XLINK + \"href\"] = track.show.url\n        show_ref.attrib[XLINK + \"show\"] = \"replace\"\n\n        ticker = E.ticker(\n            E.identifier(\"ticker-%s\" % uuid.uuid4()),\n            E.creator(\"now-playing daemon v2\"),\n            E.date(now),\n            E.show(\n                E.name(track.show.name),\n                show_ref,\n                E.startTime(\n                    isodate.datetime_isoformat(track.show.starttime.astimezone(tz))\n                ),\n                E.endTime(\n                    isodate.datetime_isoformat(track.show.endtime.astimezone(tz))\n                ),\n                id=track.show.uuid,\n            ),\n            E.track(\n                E.show(track.show.name, ref=track.show.uuid),\n                E.artist(track.artist),\n                E.title(track.title),\n                E.startTime(isodate.datetime_isoformat(track.starttime.astimezone(tz))),\n                E.endTime(isodate.datetime_isoformat(track.endtime.astimezone(tz))),\n                id=track.uuid,\n            ),\n        )\n        lxml.etree.ElementTree(ticker).write(\n            self.ticker_file_path,\n            pretty_print=True,\n            xml_declaration=True,\n            encoding=\"utf-8\",\n        )\n\n    def track_finished(self, track):\n        return True\n</code></pre>"},{"location":"reference/track/observers/ticker/#track.observers.ticker.TickerTrackObserver.Options","title":"<code>Options</code>","text":"<p>             Bases: <code>Options</code></p> <p>TickerTrackObserver options.</p> Source code in <code>nowplaying/track/observers/ticker.py</code> <pre><code>class Options(TrackObserver.Options):\n    \"\"\"TickerTrackObserver options.\"\"\"\n\n    @classmethod\n    def args(cls, args: configargparse.ArgParser) -&gt; None:\n        args.add_argument(\n            \"--xml-output\",\n            dest=\"tickerOutputFile\",\n            help=\"ticker XML output format\",\n            default=\"/var/www/localhost/htdocs/songticker/0.9.3/current.xml\",\n        )\n\n    def __init__(self, file_path: str):\n        self.file_path = file_path\n</code></pre>"}]}